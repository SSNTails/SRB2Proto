
// d_main.c :
//      DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//      plus functions to determine game mode (shareware, registered),
//      parse command line parameters, configure game parameters (turbo),
//      and call the startup functions.

#ifndef __WIN32__
#include <unistd.h>             // for access
#endif

#include <fcntl.h>

#ifdef __WIN32__
#include <direct.h>             //for mkdir
#include "WIN32/WIN_MAIN.H"
#endif

#include "doomdef.h"

#include "command.h"
#include "console.h"

#include "doomstat.h"

#include "am_map.h"
#include "d_net.h"
#include "d_netcmd.h"
#include "dehacked.h"
#include "dstrings.h"

#include "f_wipe.h"
#include "f_finale.h"

#include "g_game.h"
#include "g_input.h"

#include "hu_stuff.h"

#include "i_sound.h"
#include "i_system.h"
#include "i_video.h"

#include "m_argv.h"
#include "m_menu.h"
#include "m_misc.h"

#include "p_setup.h"
#include "p_fab.h"

#include "r_main.h"
#include "r_local.h"

#include "s_sound.h"
#include "st_stuff.h"

#include "v_video.h"

#include "wi_stuff.h"
#include "w_wad.h"

#include "z_zone.h"
#include "d_main.h"

#define BGCOLOR         7
#define FGCOLOR         8

extern int mb_used;     // base memory allocation, changeable by -mb parm.
                        // note: TEMPORARY hack, check D_DoomMain.


//
//  DEMO LOOP
//
int             demosequence;
int             pagetic;
char            *pagename;

//  PROTOS
void D_DoomLoop (void);
void D_PageDrawer (char* lumpname);
void D_AdvanceDemo (void);


char*           startupwadfiles[MAX_WADFILES];

boolean         devparm;        // started game with -devparm
boolean         nomonsters;     // checkparm of -nomonsters

boolean         singletics = false; // debug flag to cancel adaptiveness

boolean         nomusic;    //Boris stuff
boolean         nosound;


extern  boolean inhelpscreens;

boolean         advancedemo;


char            wadfile[1024];          // primary wad file
char            mapdir[1024];           // directory of development maps


//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t         events[MAXEVENTS];
int             eventhead;
int             eventtail;


//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent (event_t* ev)
{
    events[eventhead] = *ev;
    eventhead = (++eventhead)&(MAXEVENTS-1);
}
// just for lock this function
#ifdef PC_DOS
void D_PostEvent_end(void) {};
#endif


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents (void)
{
    event_t*    ev;

    //added:12-02-98: doing a W_CheckNumForName() is a bit clumsy here...

    // IF STORE DEMO, DO NOT ACCEPT INPUT
    //if ( ( gamemode == commercial )
    //     && (W_CheckNumForName("map01")<0) )
    //  return;

    for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) )
    {
        ev = &events[eventtail];
        // Menu input
        if (M_Responder (ev))
            continue;              // menu ate the event

        // console input
        if (CON_Responder (ev))
            continue;              // ate the event

        G_Responder (ev);
    }
}


//
// D_Display
//  draw current display, possibly wiping it from the previous
//
extern boolean playerdeadview; //hack from P_DeathThink()

#ifdef __WIN32__
extern int glide_view;
void I_DoStartupMouse (void);   //win_sys.c
#endif

// tyest the clientprediction
boolean gostview;

// wipegamestate can be set to -1 to force a wipe on the next draw
// added comment : there is a wipe eatch change of the gamestate
gamestate_t  wipegamestate = GS_DEMOSCREEN;

void D_Display (void)
{
    static  boolean             viewactivestate = false;
    static  boolean             menuactivestate = false;
    static  boolean             inhelpscreensstate = false;
    static  boolean             fullscreen = false;
    static  gamestate_t         oldgamestate = -1;
    static  int                 borderdrawcount;
    int                         nowtime;
    int                         tics;
    int                         wipestart;
    int                         y;
    boolean                     done;
    boolean                     wipe;
    boolean                     redrawsbar;

    if (nodrawers)
        return;                    // for comparative timing / profiling

    redrawsbar = false;

    //added:21-01-98: check for change of screen size (video mode)
    if (setmodeneeded)
    {
        SCR_SetMode();  // change video mode
    }

    if (vid.recalc)
    {
        //added:26-01-98: NOTE! setsizeneeded is set by SCR_Recalc()
        SCR_Recalc();
    }

    // change the view size if needed
    if (setsizeneeded || scr_viewsize!=cv_viewsize.value)
    {
        R_ExecuteSetViewSize ();
        oldgamestate = -1;                      // force background redraw
        borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    if (gamestate != wipegamestate &&
        rendermode == render_soft)
    {
        wipe = true;
        wipe_StartScreen(0, 0, vid.width, vid.height);
    }
    else
        wipe = false;


    if (gamestate == GS_LEVEL && gametic)
    {
        HU_Erase();
    }

    // do buffered drawing
    switch (gamestate)
    {
      case GS_LEVEL:
        if (!gametic)
            break;
        if (automapactive)
            AM_Drawer ();
        if (wipe || ((viewheight != vid.height) && fullscreen) )
            redrawsbar = true;
        if (inhelpscreensstate && !inhelpscreens)
            redrawsbar = true;              // just put away the help screen
        if (vid.recalc) //redraw (& recalc widgets) when vidmode change
            redrawsbar = true;
        if (menuactivestate)      // redraw stbar because menu fades down the
            redrawsbar = true;    // screen

        ST_Drawer (viewheight == vid.height, redrawsbar );

        fullscreen = (viewheight == vid.height);
        break;

      case GS_INTERMISSION:
        WI_Drawer ();
        break;

      case GS_FINALE:
        F_Drawer ();
        break;

      case GS_DEDICATEDSERVER:
      case GS_DEMOSCREEN:
        D_PageDrawer (pagename);
        break;
      case GS_WAITINGPLAYERS:
        // console is always draw
        break;
    }

    // draw buffered stuff to screen
    I_UpdateNoBlit ();

    // draw the view directly
    if (gamestate == GS_LEVEL)
    {
        if( !automapactive )
        {
            gostview=true;
            if ( rendermode == render_soft )
                R_RenderPlayerView (&players[displayplayer]);

            // added 16-6-98: render the second screen
            if( cv_splitscreen.value )
            {
                gostview = false;
                if ( rendermode == render_soft )
                {
                    //faB: Boris hack :P !!
                    viewwindowy = vid.height/2;
                    memcpy(ylookup,ylookup2,viewheight*sizeof(ylookup[0]));

                    R_RenderPlayerView (&players[secondarydisplayplayer]);

                    viewwindowy = 0;
                    memcpy(ylookup,ylookup1,viewheight*sizeof(ylookup[0]));
                }
            }
        }

        HU_Drawer ();

        // fullscreen with overlay
        if (st_overlay && !automapactive &&
            (!playerdeadview || cv_splitscreen.value)) //Fab: full clear view when dead
        {
            ST_overlayDrawer ();
            if(cv_splitscreen.value)
            {
                player_t *p;
                extern player_t *plyr;
                p=plyr;
                plyr=&players[secondarydisplayplayer];
                ST_overlayDrawer ();
                plyr=p;
            }
        }
    }

    // change gamma if needed
    if ((scr_gamma!=cv_usegamma.value) ||
        (gamestate != oldgamestate && gamestate != GS_LEVEL) )
    {
        scr_gamma = cv_usegamma.value;
        I_SetPalette (W_CacheLumpName ("PLAYPAL",PU_CACHE));
    }

    // clean up border stuff
    // see if the border needs to be initially drawn
    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)
    {
        viewactivestate = false;        // view was not active
        R_FillBackScreen ();    // draw the pattern into the back screen
    }


    // see if the border needs to be updated to the screen
    if( gamestate==GS_LEVEL && !automapactive &&
        (scaledviewwidth!=vid.width) )
    {
        // the menu may draw over parts out of the view window,
        // which are refreshed only when needed
        if (menuactive || menuactivestate || !viewactivestate)
            borderdrawcount = 3;

        if (borderdrawcount)
        {
            if (rendermode == render_soft)
                R_DrawViewBorder ();    // erase old menu stuff

            borderdrawcount--;
        }

    }

    menuactivestate = menuactive;
    viewactivestate = viewactive;
    inhelpscreensstate = inhelpscreens;
    oldgamestate = wipegamestate = gamestate;

    // draw pause pic
    if (paused && (!menuactive || netgame))
    {
        patch_t* patch;
        if (automapactive)
            y = 4;
        else
            y = viewwindowy+4;
        patch = W_CachePatchName ("M_PAUSE", PU_CACHE);
        V_DrawScaledPatch(viewwindowx+(BASEVIDWIDTH - patch->width)/2,
                          y,0,patch);
    }


    //added:24-01-98:vid size change is now finished if it was on...
    vid.recalc = 0;

    //FIXME: draw either console or menu, not the two
    CON_Drawer ();

    // menus go directly to the screen
    M_Drawer ();          // menu is drawn even on top of everything
    NetUpdate ();         // send out any new accumulation

//
// normal update
//
    if (!wipe)
    {
        //added:12-02-98: tilt view when marine dies... just for fun
        if (gamestate == GS_LEVEL &&
            cv_tiltview.value &&
            players[displayplayer].playerstate==PST_DEAD )
        {
            V_DrawTiltView (screens[0]);
        }
#ifdef PERSPCORRECT
        else if (gamestate == GS_LEVEL &&
                 cv_perspcorr.value )
        {
            V_DrawPerspView (screens[0], players[displayplayer].aiming);
        }
#endif
        else
        {
            //I_BeginProfile();
            I_FinishUpdate ();              // page flip or blit buffer
            //CONS_Printf ("last frame update took %d\n", I_EndProfile());
        }
        return;
    }

//
// wipe update
//
    wipe_EndScreen(0, 0, vid.width, vid.height);

    wipestart = I_GetTime () - 1;

    do
    {
        do
        {
            nowtime = I_GetTime ();
            tics = nowtime - wipestart;
        } while (!tics);
        wipestart = nowtime;
        done = wipe_ScreenWipe (wipe_Melt
                                , 0, 0, vid.width, vid.height, tics);
        I_UpdateNoBlit ();
        M_Drawer ();            // menu is drawn even on top of wipes
        I_FinishUpdate ();      // page flip or blit buffer
    } while (!done);
}



// =========================================================================
//   D_DoomLoop
// =========================================================================
extern  boolean   demorecording;

static  ULONG     oldentertics;
static  ULONG     lastrendered;
ULONG   rendergametic;

// note: the win32 version returns from this routine !
void D_DoomLoop (void)
{
    if (demorecording)
        G_BeginRecording ();

    // user settings
    COM_BufAddText ("exec autoexec.cfg\n");

    // game startup finished
    if ( gamestate!=GS_WAITINGPLAYERS )
    {
        CON_ToggleOff (); // will be done at the end of map command
    }

    // end of loading screen: CONS_Printf() will no more call FinishUpdate()
    con_startup = false;

    rendergametic = -1;
    oldentertics = I_GetTime ();

#ifndef LINUX
#ifdef __WIN32__
    if ( hWndMain!=NULL )
    {
        SetFocus(hWndMain);
        ShowWindow(hWndMain, SW_SHOW);
        UpdateWindow(hWndMain);
    }
#endif    
    //faB: make sure the app window has the focus or
    //     DirectInput acquire keyboard won't work
    CONS_Printf ("I_StartupKeyboard...\n");
    I_StartupKeyboard ();
#endif
#ifdef __WIN32__
    CONS_Printf ("I_StartupMouse...\n");
    I_DoStartupMouse ();
#endif
#ifndef __WIN32__
    while (1)
        D_DoomInnerLoop ();
#endif
}


// the DOS version can run an infinite loop
// the windows version calls this from win_main.c usual windows message loop
void D_DoomInnerLoop (void)
{
    int       entertic,realtics;

    // get real tics
    entertic = I_GetTime ();
    realtics = entertic - oldentertics;
    oldentertics = entertic;

    // frame syncronous IO operations
    // UNUSED for the moment (18/12/98)
    I_StartFrame ();

    // process tics (but maybe not if realtic==0)
    TryRunTics (realtics);

    if(singletics || (/*realtics &&*/ gametic>rendergametic))
    {
        rendergametic=gametic;
        lastrendered=I_GetTime();

        //added:16-01-98:consoleplayer -> displayplayer (hear sounds from viewpoint)
        S_UpdateSounds ();  // move positional sounds
        // Update display, next frame, with current state.
        D_Display ();
    }
    else
        if(lastrendered+2<I_GetTime()) // in case the server hang or netsplit
            D_Display ();

// Win32 exe uses DirectSound..
#ifndef __WIN32__
    //
    //Other implementations might need to update the sound here.
    //
#ifndef SNDSERV
    // Sound mixing for the buffer is snychronous.
    I_UpdateSound();
#endif
    // Synchronous sound output is explicitly called.
#ifndef SNDINTR
    // Update sound output.
    I_SubmitSound();
#endif
#endif //__WIN32__

    // check for media change, loop music..
    I_UpdateCD ();
}


// =========================================================================
//   D_AdvanceDemo
// =========================================================================

//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker (void)
{
    if (--pagetic < 0)
        D_AdvanceDemo ();
}



//
// D_PageDrawer : draw a patch supposed to fill the screen,
//                fill the borders with a background pattern (a flat)
//                if the patch doesn't fit all the screen.
//
void D_PageDrawer (char* lumpname)
{
    byte*   src;
    byte*   dest;
    int     x;
    int     y;

    // software mode which uses generally lower resolutions doesn't look
    // good when the pic is scaled, so it fills space aorund with a pattern,
    // and the pic is only scaled to integer multiples (x2, x3...)
    if (rendermode==render_soft)
    {
    if( (vid.width>BASEVIDWIDTH) || (vid.height>BASEVIDHEIGHT) )
    {
        src  = scr_borderpatch;
        dest = screens[0];

        for (y=0; y<vid.height; y++)
        {
            for (x=0; x<vid.width/64; x++)
            {
                memcpy(dest, src+((y&63)<<6), 64);
                dest += 64;
            }
            if (vid.width&63)
            {
                memcpy(dest, src+((y&63)<<6), vid.width&63);
                dest   += (vid.width&63);
            }
        }
    }
    }

    V_DrawScaledPatch(0,0, 0, W_CachePatchName(lumpname, PU_CACHE) );

    //added:08-01-98:if you wanna centre the pages it's here.
    //          I think it's not so beautiful to have the pic centered,
    //          so I leave it in the upper-left corner for now...
    //V_DrawPatch (0,0, 0, W_CachePatchName(pagename, PU_CACHE));
}


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo (void)
{
    advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
void D_DoAdvanceDemo (void)
{
    players[consoleplayer].playerstate = PST_LIVE;  // not reborn
    advancedemo = false;
    usergame = false;               // no save / end game here
    paused = false;
    gameaction = ga_nothing;

    if ( gamemode == retail )
        demosequence = (demosequence+1)%7;
    else
        demosequence = (demosequence+1)%6;

    switch (demosequence)
    {
      case 0:
        gamestate = GS_DEMOSCREEN;
        if ( gamemode == commercial )
            pagetic = TICRATE * 15; // Changed by Tails: 9-14-99
        else
            pagetic = 170;
        pagename = "TITLEPIC";
        if ( gamemode == commercial )
          S_StartMusic(mus_dm2ttl);
        else
          S_StartMusic (mus_intro);
        break;
      case 1:
        G_DeferedPlayDemo ("demo1");
        break;
      case 2:
        pagetic = 200;
        gamestate = GS_DEMOSCREEN;
        pagename = "CREDIT";
        break;
      case 3:
        G_DeferedPlayDemo ("demo2");
        break;
      case 4:
        gamestate = GS_DEMOSCREEN;
        if ( gamemode == commercial)
        {
            pagetic = TICRATE * 11;
            pagename = "TITLEPIC";
            S_StartMusic(mus_dm2ttl);
        }
        else
        {
            pagetic = 200;

            if ( gamemode == retail )
              pagename = text[CREDIT_NUM];
            else
              pagename = text[HELP2_NUM];
        }
        break;
      case 5:
        G_DeferedPlayDemo ("demo3");
        break;
        // THE DEFINITIVE DOOM Special Edition demo
      case 6:
        G_DeferedPlayDemo ("demo4");
        break;
    }
}

// =========================================================================
//   D_DoomMain
// =========================================================================

//
// D_StartTitle
//
void D_StartTitle (void)
{
    gameaction = ga_nothing;
    demosequence = -1;
    D_AdvanceDemo ();
}


//
// D_AddFile
//
void D_AddFile (char *file)
{
    int     numwadfiles;
    char    *newfile;

    for (numwadfiles = 0 ; startupwadfiles[numwadfiles] ; numwadfiles++)
        ;

    newfile = malloc (strlen(file)+1);
    strcpy (newfile, file);

    startupwadfiles[numwadfiles] = newfile;
}


#ifdef __WIN32__
#define R_OK    0                       //faB: win32 does not have R_OK in includes..
#else
#define _MAX_PATH   MAX_WADPATH         //use djgpp's PATH_MAX
#endif


// ==========================================================================
// Identify the Doom version, and IWAD file to use.
// Sets 'gamemode' to determine whether registered/commmercial features are
// available (notable loading PWAD files).
// ==========================================================================

// return gamemode for Doom or Ultimate Doom, use size to detect which one
gamemode_t GetDoomVersion (char* wadfile)
{
    struct stat sbuf;
    // and if I patch my main wad and the size gets
    // bigger ? uh?
    stat (wadfile, &sbuf);
    if (sbuf.st_size<12408292)
        return registered;
    else
        return retail;      // Ultimate
}

void IdentifyVersion (void)
{
    char*       doom1wad;
    char*       doomwad;
    char*       doomuwad;
    char*       doom2wad;
    char*       plutoniawad;
    char*       tntwad;

    char*       legacywad;

    char        pathtemp[_MAX_PATH];
    char        pathiwad[_MAX_PATH+16];

    int         p,i;

//Fab:25-04-98:unused now
//    char*       doom2fwad;

#ifdef LINUX
    char *home;
#endif
    char *doomwaddir;

    doomwaddir = getenv("DOOMWADDIR");
    if (!doomwaddir)
    {
        // get the current directory (possible problem on NT with "." as current dir)
        if ( getcwd(pathtemp, _MAX_PATH) != NULL )
            doomwaddir = pathtemp;
        else
            doomwaddir = ".";
    }

    // Commercial.
    doom2wad = malloc(strlen(doomwaddir)+1+9+1);
    sprintf(doom2wad, "%s/%s", doomwaddir, text[DOOM2WAD_NUM]);

    // Retail.
    doomuwad = malloc(strlen(doomwaddir)+1+9+1);
    sprintf(doomuwad, "%s/%s", doomwaddir, text[DOOMUWAD_NUM]);

    // Registered.
    doomwad = malloc(strlen(doomwaddir)+1+8+1);
    sprintf(doomwad, "%s/%s", doomwaddir, text[DOOMWAD_NUM]);

    // Shareware.
    doom1wad = malloc(strlen(doomwaddir)+1+9+1);
    sprintf(doom1wad, "%s/%s", doomwaddir, text[DOOM1WAD_NUM]);

    // and... Doom LEGACY !!! :)
    legacywad = malloc(strlen(doomwaddir)+1+9+1);
    sprintf(legacywad, "%s/doom3.wad", doomwaddir);

    // FinalDoom : Plutonia
    plutoniawad = malloc(strlen(doomwaddir)+1+12+1);
    sprintf(plutoniawad, "%s/plutonia.wad", doomwaddir);

    // FinalDoom : Tnt Evilution
    tntwad = malloc(strlen(doomwaddir)+1+7+1);
    sprintf(tntwad, "%s/tnt.wad", doomwaddir);

    /* French stuff.
    doom2fwad = malloc(strlen(doomwaddir)+1+10+1);
    sprintf(doom2fwad, "%s/doom2f.wad", doomwaddir);*/


#ifdef LINUX
    home = getenv("HOME");
    if (!home)
        I_Error("Please set $HOME to your home directory");
    sprintf(configfile, "%s/"CONFIGFILENAME, home);
#else
    sprintf(configfile, "%s/"CONFIGFILENAME, doomwaddir);
#endif

    if (M_CheckParm ("-shdev"))
    {
        gamemode = shareware;
        devparm = true;
        D_AddFile (DEVDATA"doom1.wad");
        D_AddFile (DEVMAPS"data_se/texture1.lmp");
        D_AddFile (DEVMAPS"data_se/pnames.lmp");
        strcpy (configfile,DEVDATA CONFIGFILENAME);
    }
    else
    if (M_CheckParm ("-regdev"))
    {
        gamemode = registered;
        devparm = true;
        D_AddFile (DEVDATA"doom.wad");
        D_AddFile (DEVMAPS"data_se/texture1.lmp");
        D_AddFile (DEVMAPS"data_se/texture2.lmp");
        D_AddFile (DEVMAPS"data_se/pnames.lmp");
        strcpy (configfile,DEVDATA CONFIGFILENAME);
        return;
    }
    else
    if (M_CheckParm ("-comdev"))
    {
        gamemode = commercial;
        devparm = true;
        /* I don't bother
        if(plutonia)
            D_AddFile (DEVDATA"plutonia.wad");
        else if(tnt)
            D_AddFile (DEVDATA"tnt.wad");
        else*/
            D_AddFile (DEVDATA"doom2.wad");

        D_AddFile (DEVMAPS"cdata/texture1.lmp");
        D_AddFile (DEVMAPS"cdata/pnames.lmp");
        strcpy (configfile,DEVDATA CONFIGFILENAME);
        return;
    }
    else
    // specify the name of the IWAD file to use, so we can have several IWAD's
    // in the same directory, and/or have legacy.exe only once in a different location
    if ( (p = M_CheckParm ("-iwad")) && p < myargc-1 )
    {
        sprintf (pathiwad, "%s/%s", doomwaddir, myargv[p+1]);
        D_AddFile (pathiwad);

        // point to start of filename only
        for (i=strlen(pathiwad)-1; i>=0; i--)
            if (pathiwad[i]=='\\' || pathiwad[i]=='/' || pathiwad[i]==':')
                break;
        i++;

        // find gamemode
        if (!stricmp("plutonia.wad",pathiwad+i))
            gamemode = commercial;
        else if (!stricmp("tnt.wad",pathiwad+i))
            gamemode = commercial;
        else if (!stricmp(text[DOOM2WAD_NUM] ,pathiwad+i))
            gamemode = commercial;
        else if (!stricmp(text[DOOMUWAD_NUM] ,pathiwad+i))
            gamemode = retail;
        else if (!stricmp(text[DOOMWAD_NUM] ,pathiwad+i))
            gamemode = GetDoomVersion (pathiwad);
        else if (!stricmp(text[DOOM1WAD_NUM] ,pathiwad+i))
            gamemode = shareware;
        else {
            gamemode = commercial;
        }
    }
    else
    /*
    if ( !access (doom2fwad,R_OK) )
    {
        gamemode = commercial;
        // C'est ridicule!
        // Let's handle languages in config files, okay?
        language = french;
        CONS_Printf("French version\n");
        D_AddFile (doom2fwad);
    }
    else*/
    if ( !access (doom2wad,R_OK) )
    {
        gamemode = commercial;
        D_AddFile (doom2wad);
    }
    else
    if ( !access (doomuwad,R_OK) )
    {
        gamemode = retail;
        D_AddFile (doomuwad);
    }
    else
    if ( !access (doomwad,R_OK) )
    {
        gamemode = GetDoomVersion (doomwad);
        D_AddFile (doomwad);
    }
    else
    if ( !access (doom1wad,R_OK) )
    {
        gamemode = shareware;
        D_AddFile (doom1wad);
    }
    else
    if ( !access (plutoniawad, R_OK ) )
    {
      gamemode = commercial;
      D_AddFile (plutoniawad);
    }
    else
    if ( !access ( tntwad, R_OK ) )
    {
      gamemode = commercial;
      D_AddFile (tntwad);
    }
    else
    {
        I_Error ("Main WAD file not found !\n");
        // unused code : I_ERROR never return
        gamemode = indetermined;
    }

    D_AddFile(legacywad);
}

//
// Find a Response File
//
void FindResponseFile (void)
{
    int             i;
#define MAXARGVS        256

    for (i = 1;i < myargc;i++)
        if (myargv[i][0] == '@')
        {
            FILE *          handle;
            int             size;
            int             k;
            int             index;
            int             indexinfile;
            char    *infile;
            char    *file;
            char    *moreargs[20];
            char    *firstargv;

            // READ THE RESPONSE FILE INTO MEMORY
            handle = fopen (&myargv[i][1],"rb");
            if (!handle)
            {
                CONS_Printf ("\nNo such response file!");
                exit(1);
            }
            CONS_Printf("Found response file %s!\n",&myargv[i][1]);
            fseek (handle,0,SEEK_END);
            size = ftell(handle);
            fseek (handle,0,SEEK_SET);
            file = malloc (size);
            fread (file,size,1,handle);
            fclose (handle);

            // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
            for (index = 0,k = i+1; k < myargc; k++)
                moreargs[index++] = myargv[k];

            firstargv = myargv[0];
            myargv = malloc(sizeof(char *)*MAXARGVS);
            memset(myargv,0,sizeof(char *)*MAXARGVS);
            myargv[0] = firstargv;

            infile = file;
            indexinfile = k = 0;
            indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)
            do
            {
                if ( *(infile+k) == '"' )       // strip encllosing double-quote
                    k++;
                myargv[indexinfile++] = infile + k;
                while ( (k < size) &&
                        ( (*(infile+k)> ' ') && (*(infile+k)<='z') ) )
                    k++;
                if ( *(infile+k-1) == '"' )     // strip ending double-quote
                    k--;
                *(infile+k) = 0;
                while(k < size &&
                      ((*(infile+k)<= ' ') || (*(infile+k)>'z')))
                    k++;
            } while(k < size);

            for (k = 0;k < index;k++)
                myargv[indexinfile++] = moreargs[k];
            myargc = indexinfile;

            // DISPLAY ARGS
            CONS_Printf("%d command-line args:\n",myargc);
            for (k=1;k<myargc;k++)
                CONS_Printf("%s\n",myargv[k]);

            break;
        }
}


/* ======================================================================== */
// Just print the nice red titlebar like the original DOOM2 for DOS.
/* ======================================================================== */
#ifdef PC_DOS
void D_Titlebar (char *title1, char *title2)
{
    // DOOM LEGACY banner
    clrscr();
    textattr((BLUE<<4)+WHITE);
    clreol();
    cputs(title1);

    textattr((RED<<4)+WHITE);
    clreol();
    gotoxy((80-strlen(title2))/2,2);
    cputs(title2);
    normvideo();
    gotoxy(1,3);

}
#endif


//added:11-01-98:
//
//  Center the title string, then add the date and time of compilation.
//
void D_MakeTitleString( char *s )
{
    char    temp[82];
    char    *t;
    char    *u;
    int     i;

    for(i=0,t=temp;i<82;i++) *t++=' ';

    for(t=temp+(80-strlen(s))/2,u=s;*u!='\0';)
        *t++ = *u++;

    u=__DATE__;
    for(t=temp+1,i=11;i--;)
        *t++=*u++;
    u=__TIME__;
    for(t=temp+71,i=8;i--;)
        *t++=*u++;

    temp[80]='\0';
    strcpy(s,temp);
}


//
// D_DoomMain
//
void D_DoomMain (void)
{
    int     p;
    char    file[256];
    char    legacy[82];    //added:18-02-98: legacy title banner
    char    title[82];    //added:11-01-98:moved, doesn't need to be global

    int     startepisode;
    int     startmap;
    boolean autostart;

    //added:18-02-98:keep error messages until the final flush(stderr)
    if (setvbuf(stderr,NULL,_IOFBF,1000))
        CONS_Printf("setvbuf didnt work\n");

    // get parameters from a response file (eg: doom3 @parms.txt)
    FindResponseFile ();

    // identify the main IWAD file to use
    IdentifyVersion ();

    setbuf (stdout, NULL);      // non-buffered output
    modifiedgame = false;

    // added 18-1-98
    // load dehacked file
    //befor any initialitation patch table and text
    p = M_CheckParm ("-dehacked");
    if (!p)
        p = M_CheckParm ("-deh");  //Fab:02-08-98:like Boom & DosDoom
    if(p!=0)
    {
        while (M_IsNextParm())
            LoadDehackedFile (M_GetNextParm());
    }

    // search for a deh in -file parm....
    if (M_CheckParm ("-file"))
    {
        while (M_IsNextParm())
        {
            char *s=M_GetNextParm();
            if(stricmp(&s[strlen(s)-3],"deh")==0)
                LoadDehackedFile (s);
        }
    }

    nomonsters = M_CheckParm ("-nomonsters");
    devparm = M_CheckParm ("-devparm");

    //added:11-01-98:removed the repeated spaces in title strings,
    //               because GCC doesn't expand the TABS from my text editor.
    //  Now the string is centered in a larger one just before output,
    //  and the date and time of compilation is added. (see below)
    switch ( gamemode )
    {
      case retail    :strcpy (title,"The Ultimate DOOM Startup");  break;
      case shareware :strcpy (title,"DOOM Shareware Startup");     break;
      case registered:strcpy (title,"DOOM Registered Startup");    break;
      case commercial:strcpy (title,"DOOM 2: Hell on Earth");      break;
/*FIXME
      case pack_plut :strcpy (title,"DOOM 2: Plutonia Experiment");break;
      case pack_tnt  :strcpy (title,"DOOM 2: TNT - Evilution");    break;
*/
      default        :strcpy (title,"Public DOOM");                break;
    }

    //added:11-01-98:center the string, add compilation time and date.
    sprintf(legacy,"Doom LEGACY v%i.%i"VERSIONSTRING,VERSION/100,VERSION%100);
    D_MakeTitleString(legacy);

#ifdef PC_DOS
    D_Titlebar(legacy,title);
#else
    CONS_Printf ("%s\n%s\n",legacy,title);
#endif

    if (devparm)
        CONS_Printf(D_DEVSTR);

    if (M_CheckParm("-cdrom"))
    {
        CONS_Printf(D_CDROM);
#ifdef __WIN32__
        mkdir("c:\\doomdata");
#else
        mkdir("c:\\doomdata",0);
#endif
        strcpy (configfile,"c:/doomdata/"CONFIGFILENAME);
    }

    // add any files specified on the command line with -file wadfile
    // to the wad list
    //
    // convenience hack to allow -wart e m to add a wad file
    // prepend a tilde to the filename so wadfile will be reloadable
    p = M_CheckParm ("-wart");
    if (p)
    {
        myargv[p][4] = 'p';     // big hack, change to -warp

        // Map name handling.
        switch (gamemode )
        {
          case shareware:
          case retail:
          case registered:
            sprintf (file,"~"DEVMAPS"E%cM%c.wad",
                     myargv[p+1][0], myargv[p+2][0]);
            CONS_Printf("Warping to Episode %s, Map %s.\n",
                   myargv[p+1],myargv[p+2]);
            break;

          case commercial:
          default:
            p = atoi (myargv[p+1]);
            if (p<10)
              sprintf (file,"~"DEVMAPS"cdata/map0%i.wad", p);
            else
              sprintf (file,"~"DEVMAPS"cdata/map%i.wad", p);
            break;
        }
        D_AddFile (file);
    }

    if (M_CheckParm ("-file"))
    {
        // the parms after p are wadfile/lump names,
        // until end of parms or another - preceded parm
        modifiedgame = true;            // homebrew levels
        while (M_IsNextParm())
        {
            char *s=M_GetNextParm();
            // deh file are loaded before
            if(stricmp(&s[strlen(s)-3],"deh")!=0)
                D_AddFile (s);
        }
    }


    // get skill / episode / map from parms
    gameskill = sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;


    p = M_CheckParm ("-skill");
    if (p && p < myargc-1)
    {
        gameskill = myargv[p+1][0]-'1';
            autostart = true;
    }

    p = M_CheckParm ("-episode");
    if (p && p < myargc-1)
    {
        startepisode = myargv[p+1][0]-'0';
        startmap = 1;
        autostart = true;
    }

    p = M_CheckParm ("-warp");
    if (p && p < myargc-1)
    {
        if (gamemode == commercial)
            startmap = atoi (myargv[p+1]);
        else
        {
            startepisode = myargv[p+1][0]-'0';
            if (p < myargc-2 &&
                myargv[p+2][0]>='0' &&
                myargv[p+2][0]<='9' )
                startmap = myargv[p+2][0]-'0';
            else
                startmap = 1;
        }
        autostart = true;
    }


    //added:11-02-98: TEMPORARY HACK to modify the base memory allocation
    //                later we'll have to do a better memory handling,
    //                with detection of available mem and w95 support.
    p = M_CheckParm ("-mb");
    if (p && p < myargc-1)
    {
        mb_used = atoi (myargv[p+1]);
        CONS_Printf ("%d megabytes requested for Z_Init.\n", mb_used);
    }

    CONS_Printf (text[Z_INIT_NUM]);
    Z_Init ();

    CONS_Printf (text[W_INIT_NUM]);
    if(!W_InitMultipleFiles (startupwadfiles))
    {
#ifdef __WIN32__
        extern  HWND    hWndMain;
        MessageBox (hWndMain, "A WAD file was not found", "Doom Legacy Error", MB_OK);
#else
        CONS_Printf("Hit ENTER\n");              // added 4-1-98
        getchar();
#endif
    }

    //added:28-02-98: check for Ultimate doom.
//    if ( (gamemode==registered) && (W_CheckNumForName("E4M1") > 0) )
//        gamemode = retail;

    // Check for -file in shareware
    if (modifiedgame)
    {
        // These are the lumps that will be checked in IWAD,
        // if any one is not present, execution will be aborted.
        char name[23][8]=
        {
            "e2m1","e2m2","e2m3","e2m4","e2m5","e2m6","e2m7","e2m8","e2m9",
            "e3m1","e3m3","e3m3","e3m4","e3m5","e3m6","e3m7","e3m8","e3m9",
            "dphoof","bfgga0","heada1","cybra1","spida1d1"
        };
        int i;

        if ( gamemode == shareware)
            I_Error("\nYou cannot -file with the shareware "
                    "version. Register!");

        // Check for fake IWAD with right name,
        // but w/o all the lumps of the registered version.
        if (gamemode == registered)
            for (i = 0;i < 23; i++)
                if (W_CheckNumForName(name[i])<0)
                    I_Error("\nThis is not the registered version.");
    }

    // If additonal PWAD files are used, print modified banner
    if (modifiedgame)
        CONS_Printf ( text[MODIFIED_NUM] );


    // Check and print which version is executed.
    switch ( gamemode )
    {
      case shareware:
      case indetermined:
        CONS_Printf (text[SHAREWARE_NUM]);
        break;
      case registered:
      case retail:
      case commercial:
        CONS_Printf (text[COMERCIAL_NUM]);
        break;
      default:
        // Ouch.
        break;
    }

   //---------------------------------------------------- READY SCREEN
    //printf("\nI_StartupComm...");

    CONS_Printf("I_StartupTimer...\n");
    I_StartupTimer ();

    // now initted automatically by use_mouse var code
    //CONS_Printf("I_StartupMouse...\n");
    //I_StartupMouse ();

#ifdef LINUX
    CONS_Printf ("I_StartupKeyboard...\n");
    I_StartupKeyboard ();
#endif

    // now initialised automatically by use_joystick var code
    //CONS_Printf (text[I_INIT_NUM]);
    //I_InitJoystick ();

    CONS_Printf("I_StartupGraphics...\n");
    I_StartupGraphics ();

   //--------------------------------------------------------- CONSOLE
    // setup loading screen
    SCR_Startup ();

    // we need the font of the console
    CONS_Printf (text[HU_INIT_NUM]);
    HU_Init ();

    COM_Init ();
    CON_Init ();

    D_RegisterClientCommands ();
    D_AddDeathmatchCommands ();
    ST_AddCommands ();
    R_RegisterEngineStuff ();
    S_RegisterSoundStuff ();

    //Fab:29-04-98: do some dirty chatmacros strings initialisation
    HU_HackChatmacros ();
  //--------------------------------------------------------- CONFIG.CFG
    M_FirstLoadConfig(); // WARNING : this do a "COM_BufExecute()"

    // set user default mode or mode set at cmdline
    SCR_CheckDefaultMode ();

    wipegamestate = gamestate;
  //-----------------------------------------------------------------

    // Initialize CD-Audio
    if (!M_CheckParm ("-nocd"))
        I_InitCD ();
    if(M_CheckParm ("-respawn"))
        COM_BufAddText ("respawnmonsters 1\n");
    if (M_CheckParm("-teamplay"))
        COM_BufAddText ("teamplay 1\n");

    if (M_CheckParm("-teamskin"))
        COM_BufAddText ("teamplay 2\n");

    if (M_CheckParm("-splitscreen"))
        CV_SetValue(&cv_splitscreen,1);

    if (M_CheckParm ("-altdeath"))
        COM_BufAddText ("deathmatch 2\n");
    else if (M_CheckParm ("-deathmatch"))
        COM_BufAddText ("deathmatch 1\n");
    if (M_CheckParm ("-fast"))
        COM_BufAddText ("fastmonsters 1\n");

    if (M_CheckParm ("-timer"))
    {
        p=atoi(M_GetNextParm());
        COM_BufAddText(va("timelimit %d\n",p ));
        CONS_Printf("Levels will end after %d minute(s).\n",p);
    }

    if (M_CheckParm ("-avg"))
    {
        COM_BufAddText("timelimit 20\n");
        CONS_Printf(text[AUSTIN_NUM]);
    }

    // push all "+" parameter at the command buffer
    M_PushSpecialParameters();

    // turbo option, is not meant to be saved in config, still
    // supported at cmd-line for compatibility
    p=M_CheckParm ("-turbo");
    if ( p && p<myargc-1)
        COM_BufAddText (va("turbo %s\n",myargv[p+1]));

    CONS_Printf (text[M_INIT_NUM]);
    M_Init ();

    CONS_Printf (text[R_INIT_NUM]);
    R_Init ();

    // init all NETWORK
    CONS_Printf (text[D_CHECKNET_NUM]);
    D_CheckNetGame ();

    //
    // setting up sound
    //
    CONS_Printf (text[S_SETSOUND_NUM]);
    nosound = M_CheckParm("-nosound");
    nomusic = M_CheckParm("-nomusic"); // WARNING: DOS version initmusic in I_StartupSound
    I_StartupSound ();
    I_InitMusic ();  // setup music buffer for quick mus2mid
    S_Init (cv_soundvolume.value, cv_musicvolume.value);

    CONS_Printf (text[ST_INIT_NUM]);
    ST_Init ();

    // check for a driver that wants intermission stats
    p = M_CheckParm ("-statcopy");
    if (p && p<myargc-1)
    {
        // for statistics driver
        extern  void*   statcopy;

        statcopy = (void*)atoi(myargv[p+1]);
        CONS_Printf (text[STATREG_NUM]);
    }

    // start the apropriate game based on parms
    p = M_CheckParm ("-record");
    if (p && p < myargc-1)
    {
        G_RecordDemo (myargv[p+1]);
        autostart = true;
    }


    // demo doesn't need anymore to be added with D_AddFile()
    p = M_CheckParm ("-playdemo");
    if (!p)
        p = M_CheckParm ("-timedemo");
    if (p && (p < myargc-1))
    {
        char tmp[MAX_WADPATH];
        // add .lmp to identify the EXTERNAL demo file
        // it is NOT possible to play an internal demo using -playdemo,
        // rather push a playdemo command.. to do.
        strcpy (tmp,myargv[p+1]);
        FIL_DefaultExtension (tmp,".lmp");

        CONS_Printf ("Playing demo %s.\n",tmp);

        if ( (p=M_CheckParm("-playdemo")) )
        {
            singledemo = true;              // quit after one demo
            G_DeferedPlayDemo (tmp);
        }
        else
            G_TimeDemo (tmp);
        gamestate=GS_WAITINGPLAYERS;
        wipegamestate = GS_WAITINGPLAYERS;

        D_DoomLoop ();
        return;         // win32 version returns (see win_main.c)
    }

    p = M_CheckParm ("-loadgame");
    if (p && p < myargc-1)
    {
        G_LoadGame (atoi(myargv[p+1]));
    }
    else
    {
        if(dedicated && server)
        {
            pagename = "TITLEPIC";
            gamestate = GS_DEDICATEDSERVER;
        }
        else
            if (autostart || netgame)
            {
                //added:27-02-98: reset the current version number
                demoversion = VERSION;
                gamestate = GS_WAITINGPLAYERS;
                wipegamestate = GS_WAITINGPLAYERS;
                gameaction = ga_nothing;
                if(server && !M_CheckParm("+map"))
                   COM_BufAddText (va("map \"%s\"\n",G_BuildMapName(startepisode, startmap)));
            }
            else
                D_StartTitle ();                // start up intro loop

    }

    D_DoomLoop ();

    // DOS never returns
    // win32 version returns (see win_main.c)
}
